# چطور یک نرم افزار فروش طلا بزنیم؟

امروز با هم دیگه میخواییم بشینیم ببینیم اگه بخواییم یه نرم افزار ساده ی فروش طلا رو با هم بسازیم چه شکلی قراره باشه و چه ویژگی هایی میتونه مفید باشه براش.

بیایین اول ببینیم یک نرم افزار چه ویژگی هایی میتونه داشته باشه؟

ولی این خیلی سطح بالاست، بیایین با هم دیگه اول ببینیم انواع کد زدن چیه؟

## 1- انواع کد

ما در طول زندگی حرفه‌ای برنامه نویسیمون فقط کد نمیزنیم که کد زده باشیم و معمولا هرچیزی زده یا ساخته می‌شه برای یک هدف خاص هست، بعضی ها ممکنه به کوچیمی عملگر های جمع باشن و یا الگوریتم های ساده باشن یا نرم افزار های ساده یا حتی چیزای پیچیده تری که ممکنه یک سیستم عامل یا یک هوش مصنوعی یا اصلا گوگل باشه.

جدای از زبان و فریم‌ورکی که استفاده می‌کنیم، اصلا ماهیت این کدایی که با هم میزنیم فرق داره نه؟ درسته تو همش یه چیزی میگیم که ماشین بفهمه ولی خب اون سطح استفاده و ابزار های مورد نیازشون با هم خیلی فرق داره و تو هرکدوم باید خودمون به یک رویه ی درست برسیم تا بتونیم از پس تسک یا خواستمون به بهترین شیوه‌ی ممکن بر بیاییم و تا حد ممکن خواسته‌های مسئله رو هندلشون کنیم.

اما انواع این کد‌ها چیاست؟

### 1-1 کد‌های بی هدف

تو این نوع کد معمولا بدون هیچ هدف خاصی صرفا برای یاد گیری یا تمرین اصلا یه چیزی کلک بازی میاییم و یه سری کد رو بدون هیچ هدف خاصی پشت سر هم میذاریم و معمولا هم بعد یه مدتی دور انداخته می‌شن و اصلا ساختارمند نیستن و به درد هیچکس نمیخورن. معمولا آدما وقتی دنبال ایده میگردن یا میخوان یه چیزی رو تست کنن یا یه چیزی رو یاد بگیرن از این نوع کد‌ها استفاده میکنن.

### 1-2 کد‌های معمولی

یه سری کد مثل زدن بازی سنگ کاغذ قیچی یا ماشین حساب که معمولا باز هم در سطح خیلی جونیور هستند و یا یه چیزی رو میخوان یاد بگیرن هستند که معمولا داخل درس مبانی برنامه نویسی اغلب از این نوع کد‌ها استفاده می‌شه و در نهایت هم تو آینده ممکنه بشن بخشی از الگوریتم حل مسئله‌ی شما. در واقع باقی انواع کد از اینجا به بعد ترکیبی از این ها هستند و این کد‌های معمولی که میتونه شامل یه تابع فیبوناچی یا یه تابع مرتب سازی یا یه تابع محاسبه‌ی مساحت یا حجم یا یه تابعی برای محاسبه‌ی مسافت بین دو نقطه باشه میشن یه آجری برای استفاده تو یه پروژه‌ی بزرگ تر.

تو انواع این کد‌ها میشه به پیاده سازی الگوریتم های ساده و سورتینگ و یا پیاده سازی پروژه های کوچیک و ... اشاره کرد که معمولا کل فانکشنالیتی تو یک فایل هست و نیازی به جدا کردن نیست. فرق این کد های معمولی با اون کد های بی هدف اینه که این کد ها معمولا به شکل کلاس یا تابع زده میشن و در آینده به درد میخورن و اگه کد های شما امکان این رو ندارن که در جای دیگه ای استفاده بشن کد‌های بی هدف برده می‌شن و فاقد ارزشی جز ایده گرفتن و یا یادگیری هستند.

### 1-3 کد‌های پیشرفته

این کد ها همون کد های بالا هستند منتها فانکشنالیتیشون هدفمند تره و میدونیم ممکنه جای دیگه ای هم به شکل کپی پیست استفاده بشن ولی خیلی همچنان به درد بخور نیستند.

### 1-4 پکیج ها

به بخشی از این کد های پیشرفته که جوری زده می‌شن که باقی برنامه نویس ها بتونن به راحتی ازش استفاده کنند میگن پکیج. البته من این اسم رو تو ذهن خودم روش گذاشتم و ممکنه خیلی علمی نباشه ولی بازم خالی از لطف نیست دونستنش.

اقلب اوقات این کد ها یا پکیج ها بیلدینگ بلاک هایی هستند برای کد های آینده که خودشون از یه سری کد معمولی تشکیل شدن.

از این پکیج ها میتونید توی هر زبون برنامه نویسی به کرات پیدا کنین و معمولا اقلب ویژگی های مورد نظر ما تو دنیای برنامه نویسی تو همین پکیج ها پیاده و پیدا می‌شه و ما نیازی نیست خیلی چیزی خودمون رو از صفر پیاده کنیم. مثلا برای گرفتن دترمینان خب میتونی از یه بخشی از پکیج نامپای استفاده کنی. حالا تو اینجا نامپای پکیج هست و اون بخشی داخلش که به پیاده سازی کل روابط ریازی و اینترفیس‌هاش میپردازه یه کد پیشرفته هست و باز این بخش پیشرفته خودش از یه سری کد معمولی تشکیل شده.

معمولا پکیج ها خیلی کار ما رو راحت تر میکنن ولی یه نکته مهم درموردشون اینه که اگه از پکیجی زیاد استفاده میکنین حتما خودتون یه نگاه گذرایی به سورس کد هاش بندازین شاید خودتون بتونید بخشیش رو بهبود بدید و یا اصلا ازش ایده بگیرین. ولی حتما بخونید حتما بخونین چون خیلی مهم هست بدونین ابزاری که ازش استفاده می‌کنید چجوری کار می‌کنه.

### 1-5 نرم افزار

به یک سری کد و پکیج که به منظور هدف خاصی دور هم جمع شدن یک نرم افزار میگیم تو اینجا حالا چرا این رو از کد جدا می‌کنیم؟ چون اینجا جایی هست که تازه شما به عنوان یک توسعه دهنده پا رو وسط می‌ذارین. در واقع تو یک نرم افزار میلیون ها خط ممکنه استفاده بشه و کلی فانکشنالیتی مجزا که ما توانایی درک همشون رو نداریم یا اصلا اگر چنین مهارتی هم داشته باشیم وقت پیاده سازی همش رو نداریم برای همین یبار میشینیم کد های مورد نظرمون رو می‌نویسیم یه جا به شکل پکیج و یا از پکیج های بقیه استفاده می‌کنیم و یه نرم افزار رو پیاده می‌کنیم.

اگه حس میکنین چنین کاری نمی‌کنین خب یا خیلی گادین تو برنامه نویسی که به این درجه از عرفان رسیدید که می‌تونین همه چی رو از صفر خودتون پیاده سازی کنین که بسم الله ما به شما ایمان داریم در غیر این صورت اگر چنین کاری رو انجام نمی‌دید خب شما صرفا دارید قتتون رو تلف میکنین (البته اگر به دنبال یاد گیری نیستید من یاد گیری رو کلا جدا کردم از این بخش.)

## ویژگی‌های نرم افزار

یک نرم افزار خوب و خوشگل یه سری ویژگی باید داشته باشه که اونا رو من تعیین نمی‌کنم بلکه شما و فرهنگ برنامه نویسی اون جایی که دارید توش کار می‌کنین مشخصش می‌کنید ولی به نظر من یه نرم افزار خوب تو یک شرایط مشخص (شرایط ها ممکنه با هم فرق کنه. مثلا شما وقتی وقت براتون مهم هست صرفا میزنید و خاسته مسئله رو میرسونین و اگه نیاز شد جایی رو تغییر میدید ولی اگه نیازی نباشه خب مشخصا تغییرش نمی‌دید ولی اگه وقت براتون مهم نیست خیلی و یا حس میکنین نیاز دارید در ادامه کدتون خیلی قراره بزرگ تر شه و یا تغییر کنه خب پس با ما همراه باشید با ادامه. ) باید یه سری داشته باشه. از نمونش اینه که درسته نیازی نیست میکروسرویس بزنین همیشه ولی سعی کنین حداقل تا حد ممکن توابع فایل ها و اپ هاتون رو از هم بشکونید.

یعنی چی؟ یعنی مثلا همش رو یه جا نزنین یا همش رو تو یک فانکشن نزنید. فانکشن ها باید هر کدوم برای کار جدایی باشند و هیچ فانکشنی نباید دو تا کار رو انجام بده. اینجوری هم کدتون خوانا تره و همم تغییر توش راحت تره و اگه جایی به مشکل بخوره نفر بعدی میتونه راحت اون رو تغییر بده. از طرف دیگه ای دیگه حذف یا اضافه کردن یه ویژگی جدید به نرم افزار خیلی دردسر نداره و می‌شه به راحتی اون رو انجام داد.

اما چجوری؟ بیاین یه مثال بزنیم

فرض کنین شما تو این افزار فروش طلاتون قراره طلا بفروشید و بخرید و هم یوزر اضافه کنین و هم بلاگ داشته باشین و هم ماشین حساب و بخش خبر و ایمیل و کلی چیز دیگه خب الان اگه بخوایی این رو پیاده سازی کنی تو یه فایل و همش تو یه فانکشن باشه پدرت در میاد در آینده برای این که بخوایی یه ویژگی بهش اضافه کنی و همینطور کلی دیباگش سخته و اصلا قشنگ نیست. این نمونه بارز نداشتن تفکر دولوپر بودنه و این یعنی شما تو کد نویس بودن گیر کردید. دقت کنین که کد نویس بودن خیلییی چیزی خوبی هست ولی خب شما الان دارید یک نرم افزار توسعه می‌دید و هر جایی فرهنگ مناسب خودش رو میطلبه و اگه شما مثل یک کد نویسی به قضیه فکر کنین صرفا دهن باقی دولوپر ها و همچنین آینده ی اون پروژه رو به فنا میدید و کدتون صرفا یک کد یک بار مصرف میشه که قرار نیست هیچ وقت تغییر خاصی بکنه. حواستون همیشه باید باشه که چه کاری دارید انجام می‌دید. اگه کد میزنین خب کد بزنین ولی اگه دارید نرم افزار توسعه می‌دید باید تا حد ممکن به فکر آینده‌ی پروژه باشید (البته زیاده روی نکنین.) و بدونین چجوری می‌شه اون رو از هم شکوند. یه سری چیز هست که من تو این مدت بهشون رسیدم در این مورد.

- از کلاس ها و توابع زیاد استفاده کنین و کد هاتون رو بشکونید.
- توابع رو با هم قاطی نکنین و زنچیره وار ازشون استفاده نکنین. سعی کنین یه تابع رابط داشته باشید برای صدا زدن مثلا این مورد رو نگاه کنین.

  ```python
  import random

  users = {
      1: {
          "id": 1,
          "name": "ali",
          "last_name": "alavi"
      },
      2: {
          "id": 2,
          "name": "reza",
          "last_name": "rezai"
      }
  }

  def get_user():
      return random.randint(0, len(users) - 1)

  def get_username(user_id):
      return users[user_id]["name"]

  def main():
      user_id = get_user()
      print(get_username(user_id))
  ```

  شما الان می‌تونستید خیلی راحت `get_user` رو داخل تابع `get_username` صدا بزنین ولی خب ممکنه یه جا یکی بخواد یه یوزر خاص رو بگیره بجای این که یوزر رندوم بگیره.
  خیلی چیز زیادی اضافه نمی‌کنه به کدتون ولی خب می‌تونین از هر دو تابع هر جایی دوست دارید استفده کنین و صرفا دیپندنسی هاشون رو کمتر کردید و روابط رو خودتون مدیریت می‌کنین. حالا این مثال واضع و مسخره بود ولی تو پروژه های بزرگ تر خیلی چنین مواردی پیش میاد که میاییم زنجیره وار از توابع استفاده می‌کنیم در صورتی که می‌شه هرکدوم رو نوشت و  بعد تو یه تابع دیگه اون فلو رو کنترل کرد تا جربان زیر دستمون باشه و از طرفی شخص با خوندن همچون چند خط کد کل پروژه دستش میاد و کار راحت تره. حالا اصلا اگه بخوام یکی از توابع رو تغییر هم بدم خیلی فرقی نمی‌کنه تو پروژه و اینجوری نگه داریش راحت تر می‌شه.

- سعی کنین هارد کد نکنین. هارد کد کردن یعنی نابود کردن پروژه سعی کنین همیشه تو یه بخش کانفیگی چیزی کل مقدار های اساسی رو نگه دارید و به هیچ وجه هارد کد نکنین چیزی رو . اصلا مثلا شاید تو مورد بالا به نظر نیاد ولی اونجا هم هارد کد داره. چحوری درستش کنیم؟ نمونه اولش تابع `get_user` هست که به وضوح هارد کده. بهتر نبود می‌نوشتیم:

  ```python
    def get_user(start = 0, end = None):
        if end is None:
            end = len(users) - 1
        return random.randint(start, end)
  ```

  اینجوری شخص می‌تونه بازه یوزر هاش رو تغییر بده بدون این که تغییری در اصل موضوع پیش بیاد.
  یا مثلا برای تابع پایینش نمی‌شد اینجوریش کرد؟

  ```python
    def get(user_id, key = "name"):
        return users[user_id][key]
  ```

  اینجوری شاید شخص دلش یک چیز دیگه رو بخواد و ما بدون تغییر در اصل موضوع تونستیم این کار رو انجام بدیم و دیگه نیازی به پیاده سازی تابع جدید نیست. از طرفی تابعمون دو کار رو انجام نمیده بلکه صرفا اون بخشی رو که بخواییم از یه یوزر بهمون می‌ده و این باعث می‌شه کدمون طولانی نشه و خودش رو تکرار نکنه. پیدا کردن چنین مواردی و سعی به درست کردنشون یکی از مواردی هست که باعث میشه کد خیلی حجمش کمتر بشه و دیگه پیچیدگی بیش از حد نداشته باشه. معمولا وقتی دارین کد می‌زنین بعد این که تسکتون یا اون بخش از تسکتون تموم شد برگردید ببینید چنین مواردی رو به کرات مشاهده می‌کنین و اگه یکم وقت بذارید و مرتبش کنین و موارد اضافی رو حذف کنین حجم کدتون یک سوم می‌شه و دیگه نیازی نیست که همیشه به کدتون نگاه کنید و ببینید چیزی تکرار شده یا نه.
  همم این که می‌تونین از اون بخش تو جاهای دیگه هم استفاده کنین و نسبتا خیلی مرتب تر می‌شه. حالا باقی چیزا رو هم بر اساس همین می‌تونید بنویسید.
  
- کارایی تابعتون رو مشخص کنین. یه راه سادش استفاده از کامنت هاست و یا حالا تو اکثر زبون‌های خاص استفاده از داک استرینگ ها کار رو خیلی راحت می‌کنه. دیگه حتی کسی که بعد شما میاد یا اصلا خودتون نیازی نیست کد ها رو بخونین و این کار رو خیلی راحت تر می‌کنه.
  
  ```python
  def get_user(start=0, end=None):
      """
      Returns a random user ID within the specified range.

      Parameters:
      start (int): The starting index of the range (inclusive). Default is 0.
      end (int, optional): The ending index of the range (inclusive). Default is None, which means the last index of the users list.

      Returns:
      int: A random user ID within the specified range.
      """
      if end is None:
          end = len(users) - 1
      return random.randint(start, end)


  def get(user_id, key="name"):
      """
      Retrieve a specific attribute of a user.

      Args:
          user_id (int): The ID of the user.
          key (str, optional): The attribute to retrieve. Defaults to "name".

      Returns:
          The value of the specified attribute for the user.

      Raises:
          KeyError: If the user ID is not found in the users dictionary.
      """
      return users[user_id][key]
  ```

  - درسته که این متن ها خیلی طولانی شدند ولی تو اکثر مواقع کلاس ها و توابع خیلی بزرگتر و پیچیده هستن و چنین متن هایی هرچند یکم شلوغ کنند کد رو ولی به شدت به درک بهتر کد کمک می‌کنین و این که همیشه آپدیت باشن باعث میشه سرعت توسعه‌ی نفر بعدی و یا حتی خودتون در آینده به کرات زیاد شه و دیگه مشکل خاصی برای فهم نداشته باشید. نکته مهم واضح بودن متن هست. مثلا نوع ورودی ها و همینطور تایپشون و همینوطر نوع خروجی و تایپش و کاربردش و همینطور انواع خطا هایی که ممکنه رخ بدن رو بگید خیلی می‌تونه کمک کنه در هندل کردنشون.

- مشخص کردن کامل نوع ورودی و نوع خروجی: حالا درسته که ما تو متن داک استرینگ مشخص کردیم ولی مشخص بودنش تو کد هایی مثل پایتون و جاوا اسکریپت باعث کاهش ۸۰ درصدی خطاهای موقع پروداکشن می‌شه و بهتره که این مورد رو حتما مد نظر داشته باشید. مثلا به طور خلاصه در کد بالا

  ```python
  import random
  from typing import Dict, Optional

  users: Dict[int, Dict[str, str]] = {
      1: {"id": 1, "name": "ali", "last_name": "alavi"},
      2: {"id": 2, "name": "reza", "last_name": "rezai"},
  }


  def get_user(start: int = 0, end: Optional[int] = None) -> int:
      """
      Returns a random user ID within the specified range.

      Parameters:
      start (int): The starting index of the range (inclusive). Default is 0.
      end (int, optional): The ending index of the range (inclusive). Default is None, which means the last index of the users list.

      Returns:
      int: A random user ID within the specified range.
      """
      if end is None:
          end = len(users) - 1
      return random.randint(start, end)


  def get(user_id: int, key: str = "name") -> str:
      """
      Retrieve a specific attribute of a user.

      Args:
          user_id (int): The ID of the user.
          key (str, optional): The attribute to retrieve. Defaults to "name".

      Returns:
          The value of the specified attribute for the user.

      Raises:
          KeyError: If the user ID is not found in the users dictionary.
      """
      return users[user_id][key]
  ```

  حالا این تایپ‌هایی که من دادم از نظر تایپ چکینگی خیلی دقیق نیستند ولی خب برای من تا حد خوبی کار رو راه می‌ندازه و می‌تونم با دقت به نوع ورودی و خروجی حجم عظیمی از خطا ها رو کاهش بدم.
  به قول معروف هرچقدر تو دولوپ بیشتر خطا بگیری تو پروداکشن کمتر به خطا می‌خوری.  

بازم اگه چیزی یادم اومد اضافه می‌کنم ولی فعلا بریم سراغ ادامه‌ی راه.

ببین به طور کلی ما ممکنه دسته‌های مختلفی از کد رو داشته باشیم

ما تو دیتابیس برای هر تیبلی چهار تا کاربرد اصلی برای سر و کار داشتن با خود دیتا و یدونه هم سرچ لازم داریم

create_user
retrive_user
update_user
delete_user
search_user

create_animal
retrive_animal
update_animal
delete_animal
search_animal

create_sell
retrive_sell
update_sell
delete_sell
search_sell

اما یوزر چجوری از اینا استفاده کنه؟
خب براش فرانت اند مینویسیم چجوری؟
مثلا میتونیم مثل اون پروژه فروشگاهی تو تو cmd اجراش کنیم که بهش اصطلاحا میگن cli  یا commandline interface
یا میتونیم تو qt استفاده کنیم یا اندروید یا تو وب مهم نیست

مهم اینه چجوری میخوایی استفاده کنی؟
باید در نظر بگیری که ما باید یه هسته داشته باشیم که جدای از چیزای اطرافش و امکانات کاربر برامون کاربرد های اصلی رو مهیا کنه مثلا همین چیزایی که گفتم دیگه این که چه یوزری سرچ کنی یا یوزر چند بار خریده یا چه یوزری خریده یا من چیا خریدم دیگه استفاده از ایناست دیگه و خیلی مهم نیست مهم اینه بتونی درک کنی چه چیزایی هسته هستن

حالا بیا فرض کنیم که میخواییم این کد سی تو رو توی وب نمایش بدیم ولی این کار اصلا منطقی نیست چون مرورگر فقط html css js wasm رو پشتیبانی میکنه تقریبا (البته چیزای دیگه ای هم هستن که مهم نیستن) و ما کدومون سی هست

حالا برای این کار نیازه که یکم منطقی تر بشینیم و یه جوری این اطلاعات رو به هم برسونیم
اگه یادت باشه ما تو درس شبکه داشتیم راجع به یه چیزایی صحبت میکردیم تحت عنوان http و گفتیم که میتونیم پیام ها رو از طریق http و بر بستر اینترنت انتقال بدیم یعنی تو اگه یه سرور بیاری بالا و بعد این پیام ها رو انتقال بدی مرورگر میتونه اون ها رو باز کنه
یعنی تو یه فایل جاوا اسکریپتی بنویسی که هر وقت طرف بازش کرد اجرا شه و یه درخواست به این سرور تو بزنه و بگه داداش این اطلاعات رو بده به من
حالا این وسط چی بین فرانت اند و بک انده؟ آفرین api یا به طور کلی Application Programming Interface که چیز خاصی نیست
شما یه سرویس رو کال میکنی و اون یه درخواستی رو به تو جواب میده همین

مثل گارسون میمونه و یه قالب کلی مشترک هست بین چیزای مختلف که روش توافق میکنن که دیتا رو اینجوری بدن یه چیزی مثل همون توضیحاتی که در مورد http گفتم که مثلا اولش متد رو مینویسن و بعد درخواست رو بعد اگه پست بود دیتا رو مینویسن
حالا بیا یکم کلی ترش کنیم

بیا فایل های مرتبط با هرکدوم از اون تیبل ها رو جدا بذاریم

User

Animal

Sell

حالا برای این که بتونیم خوب از هم جدا کنیم و درک کنیم و کل کد ها رو تو یه فایل ننویسیم میاییم یه حالت کلی میذاریم که قشنگ تر شه
این برای هر برنامه نویس فرق میکنه و یه چهارچوب ذهنیه مثلا تو دوست داری همش رو یه جا بنویسی ولی من دوست دارم برای هر اپم اینار و داشته باشم
model
view
url
serializer
controller

کاربری اینا چیه؟
تو بخش مدل صرفا مدل های دیتابیس رو میتویسم که مثلا بیا برای app یوزر بنویسیم

model of users:
User:

- id
- name
- last_name

همین
تو بخش بعدی بخش
controller هست
یه سری چیزای مرتبط با دیتابیس
